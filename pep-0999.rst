PEP: 0999
Title: Specifying external dependencies in pyproject.toml
Author: Pradyun Gedam <pradyunsg@gmail.com>,
        Ralf Gommers <ralf.gommers@gmail.com
Discussions-To: https://discuss.python.org/t/TODO
Status: Draft
Type: Standards Track
Topic: Packaging
Content-Type: text/x-rst
Created: 16-Feb-2023
Post-History: 16-Feb-2023,
Resolution:


Abstract
========

This PEP specifies how to write a project's external, or non-PyPI, build and
runtime dependencies in a ``pyproject.toml`` file for packaging-related tools
to consume.

.. warning::

    TODO: does `core metadata`_ need to be extended with these dependencies? Or can we reuse
    `Requires-External <https://packaging.python.org/en/latest/specifications/core-metadata/#requires-external-multiple-use>`__ ?
    It seems fine to reuse at this sight? That would also settle whether or not to use environment markers - they're supported already here, so yes.
    Are we actually expecting anyone to use the core metadata? If so, we
    probably need a different key for each field (build vs. host, optional or
    not, etc.). But for our current use cases, I'd expect tools to use
    ``pyproject.toml``, not the core metadata.


Motivation
==========

Python packages may have dependencies on build tools, libraries, command line
tools, or other software that is not present on PyPI. Currently there is no way
to express those dependencies in standardized metadata. Key motivators for
this PEP are:

- Enable tools to automatically map external dependencies to packages in other
  packaging repositories,
- Make it possible to include needed dependencies in error messages emitting by
  Python package installers and build frontends,
- Provide a canonical place for package authors to record this dependency
  information.

Packaging ecosystems like Linux distros, Conda, Homebrew, Spack, and Nix need
full sets of dependencies for Python packages, and have tools like pyp2rpm_
(Fedora), Grayskull_ (Conda), and dh_python_ (Debian) which attempt to
automatically generate dependency metadata automatically from the metadata in
upstream Python packages. External dependencies are currently handled manually,
because there is no metadata for this in ``pyproject.toml`` or any other
standard metadata file. Enabling automating this conversion is a key benefit of
this PEP, making packaging Python easier and more reliable. In addition, the
authors envision other types of tools making use of this information, e.g.,
dependency analysis tools like Dependabot_ and libraries.io_.

Packages with external dependencies are typically hard to build from source,
and error messages from build failures tend to be hard to decipher for end
users. Missing external dependencies on the end users system are the most
likely cause of build failures. If installers can show the required external
dependencies as part of their error message, this may save users a lot of time.

At the moment, information on external dependencies is only captured in
installation documentation of individual packages. It is hard to maintain for
package authors and tends to go out of date. It's also hard for users and
distro packagers to find it. Having a canonical place to record this dependency
information will improve this situation.

This PEP is not trying to specify how the external dependencies should be used,
nor a mechanism to implement a name mapping from names of individual packages
that are canonical for Python projects published on PyPI to those of other
packaging ecosystems. Those topics should be treated in separate PEPs which may
lead to changes or additions to what this PEP specifies.

*TODO: decide if we write a parallel PEP for the name mapping mechanism now, or
fold it into this PEP after all.*


Rationale
=========


Types of external dependencies
------------------------------

Multiple types of external dependencies can be distinguished:

- Concrete packages that can be identified by name and have a canonical
  location in another language-specific package repository. E.g., Rust
  packages on `crates.io <https://crates.io/>`__, R packages on
  `CRAN <https://cran.r-project.org/>`__, JavaScript packages on the
  `npm registry <https://www.npmjs.com/>`__.
- Concrete packages that can be identified by name but do not have a clear
  canonical location. This is typically the case for libraries and tools
  written in C, C++, Fortran, CUDA and other low-level languages. E.g.,
  Boost, OpenSSL, Protobuf, Intel MKL, GCC.
- "Virtual" packages, which are names for concepts, types of tools or
  interfaces. These typically have multiple implementations, which *are*
  concrete packages. E.g., a C++ compiler, SSL, BLAS, LAPACK, OpenMP, MPI.

Concrete packages are straightforward to understand, and are a concept present
in virtually every package management system. Virtual packages are a concept
also present in a number of packaging systems - but not always, and the details
of their implementation varies. 


Cross compilation
-----------------

Cross compilation is not yet (as of April 2023) well-supported by stdlib
modules and ``pyproject.toml`` metadata. It is however important when
translating external dependencies to those of other packaging systems (with
tools like ``pyp2rpm``). Introducing support for cross compilation immediately
in this PEP is much easier than extending ``[external-dependencies]`` in the
future, hence the authors choose to include this now.

Terminology
'''''''''''

This PEP uses the following terminology:

- *build machine*: the machine on which the package build is being executed
- *host machine*: the machine on which the produced artifact will be installed
  and run
- *build dependency*: dependency for building the package that needs to be
  present on the build machne
- *host dependency*: dependency for building the package that needs to be
  present on the host machne

Note that this terminology is not consistent across build and packaging tools,
so care must be taken when comparing build/host dependencies in
``pyproject.toml`` to dependencies from other package managers.

Note that "target machine" or "target dependency" is not used in this PEP. That
is typically only relevant for cross-compiling compilers or other such advanced
scenarios - this is out of scope for this PEP.

Build and host dependencies
'''''''''''''''''''''''''''

Build dependencies are needed during the build process - they may be compilers,
code generators, or other such tools. In case the use of a build dependency
implies a runtime dependency, that runtime dependency should not be declared
explicitly. For example, when compiling Fortran code with ``gfortran`` into a
Python extension module, the package likely incurs a dependency on the
``libgfortran`` runtime library. *Rationale for not explicitly listing such
runtime dependencies: (a) it may depend on compiler/linker flags or details of
the build environment whether the dependency is present, and (b) these runtime
dependencies can be detected and handled automatically by tools like
``auditwheel``.*

When host dependencies are declared and a tool is not cross-compilation aware
and has to do something with external dependencies, the tool MAY merge the
``host-requires`` list into ``build-requires``. This may for example happen if
an installer like ``pip`` starts reporting external dependencies as a likely
cause of a build failure when a package fails to build from an sdist.


Specifying external dependencies
--------------------------------

Concrete package specification through PURL
'''''''''''''''''''''''''''''''''''''''''''

The two types of concrete packages are supported by PURL_ (Package URL), which
implements a scheme for identifying packages that is meant to be portable
across packaging ecosystems. Its design is::

    scheme:type/namespace/name@version?qualifiers#subpath 

The ``scheme`` component is a fixed string, ``pkg``, and of the other
components only ``type`` and ``name`` are required. As an example, a package
URL for the ``requests`` package on PyPI would be::

    pkg:pypi/requests

Adopting PURL to specify external dependencies in ``pyproject.toml`` solves a
number of problems at once - and there are already implementations of the
specification in Python and multiple languages. PURL is also already supported
by dependency-related tooling like SPDX (see
`External Repository Identifiers in the SPDX 2.3 spec <https://spdx.github.io/spdx-spec/v2.3/external-repository-identifiers/#f35-purl>`__),
the `Open Source Vulnerability format <https://ossf.github.io/osv-schema/#affectedpackage-field>`__,
and the `Sonatype OSS Index <https://ossindex.sonatype.org/doc/coordinates>`__;
not having to wait years before support in such tooling arrives is valuable.

For concrete packages without a canonical package manager to refer to, either
``pkg:generic/pkg-name`` can be used, or a direct reference to the VCS system
that the package is maintained in (e.g., ``pkg:github/pkg-name``). Which of
these is more appropriate is situation-dependent. This PEP recommends using
``pkg:generic`` when the package name is unambiguous and well-known (e.g.,
``pkg:generic/git`` or ``pkg:generic/openblas``), and using the VCS as the PURL
type otherwise.

Virtual package specification
'''''''''''''''''''''''''''''

There is no ready-made support for virtual packages in PURL or another
standard. There are a relatively limited number of such dependencies though,
and adoption a scheme similar to PURL but with the ``virtual:`` rather than
``pkg:`` scheme seems like it will be understandable and map well to Linux
distros with virtual packages and the likes of Conda and Spack.

Versioning
''''''''''

Support in PURL for version expresses and ranges is still pending, see
`vers implementation for PURL`_. In the absence of that support, the authors of
this PEP choose to not support versioning for external dependencies yet.


Dependency specifiers
'''''''''''''''''''''

*TODO: do we allow dependency specifier like ``; platform_system=='Linux'`
behind PURLs? On the one hand: perhaps not, because PURL has its own qualifiers
with ``?`` and the accepted ones depend on the PURL type. On the other hand,
we'll need something that maps to many other package managers, so then it's
best to have a uniform system for this. And the semantics for doing this the
regular Python packaging way are well-understood.*


Specification
=============

If metadata is improperly specified then tools MUST raise an error to notify
the user about their mistake.


Details
-------

.. note::

   ``pyproject.toml`` content is in the same format as in :pep:`621`

Table name
''''''''''

Tools MUST specify fields defined by this PEP in a table named
``[external-dependencies]``. No tools may add fields to this table which are
not defined by this PEP or subsequent PEPs.
The lack of an ``[external-dependencies]`` table means the package either does
not have any external dependencies, or the ones it does have are assumed to be
present on the system already.

``build-requires``/``optional-build-requires``
''''''''''''''''''''''''''''''''''''''''''''''

- Format: Array of PURL_ strings (``build-requires``) and a table
  with values of arrays of PURL_ strings (``optional-build-requires``)
- `Core metadata`_: TODO

The (optional) external build requirements needed to build the project.

For ``build-requires``, it is a key whose value is an array of strings. Each
string represents a build requirement of the project and MUST be formatted as
either a valid PURL_ string or a ``virtual:`` string. Each string maps directly
to a ``TODO`` entry in the `core metadata`_.

For ``optional-build-requires``, it is a table where each key specifies an
extra set of build requirements and whose value is an array of strings. The
strings of the arrays MUST be valid PURL_ strings. The keys MUST be valid
values for the ``TODO`` `core metadata`_. Each value in the array thus becomes
a corresponding ``TODO`` entry for the matching ``TODO`` metadata.

``host-requires``/``optional-host-requires``
''''''''''''''''''''''''''''''''''''''''''''

- Format: Array of PURL_ strings (``host-requires``) and a table
  with values of arrays of PURL_ strings (``optional-host-requires``)
- `Core metadata`_: TODO

The (optional) external host requirements needed to build the project.

For ``host-requires``, it is a key whose value is an array of strings. Each
string represents a host requirement of the project and MUST be formatted as
either a valid PURL_ string or a ``virtual:`` string. Each string maps directly
to a ``TODO`` entry in the `core metadata`_.

For ``optional-host-requires``, it is a table where each key specifies an
extra set of host requirements and whose value is an array of strings. The
strings of the arrays MUST be valid PURL_ strings. The keys MUST be valid
values for the ``TODO`` `core metadata`_. Each value in the array thus becomes
a corresponding ``TODO`` entry for the matching ``TODO`` metadata.



``dependencies``/``optional-dependencies``
''''''''''''''''''''''''''''''''''''''''''
- Format: Array of PURL_ strings (``dependencies``) and a table
  with values of arrays of PURL_ strings (``optional-dependencies``)
- `Core metadata`_: TODO

The (optional) dependencies of the project.

For ``dependencies``, it is a key whose value is an array of strings.
Each string represents a dependency of the project and MUST be
formatted as either a valid PURL_ string or a ``virtual:`` string. Each string
maps directly to a ``TODO`` entry in the `core metadata`_.

For ``optional-dependencies``, it is a table where each key specifies
an extra and whose value is an array of strings. The strings of the
arrays MUST be valid PURL_ strings. The keys MUST be valid values
for the ``TODO`` `core metadata`_. Each value in the array
thus becomes a corresponding ``TODO`` entry for the matching
``TODO`` metadata.

Temporary notes on cross-compiling
----------------------------------

E.g., conda-forge uses ``build``, ``host`` and ``run`` keys; for
non-cross-compiling jobs ``host`` dependencies equal ``build`` dependencies.
Spack has this too, in a similar form: dependencies have a keyword ``type``
which can be a string or tuple of strings - "build", "link", "run".
``type="build"`` are build systems and code generators, a header-only library
like ``pybind11`` is ``("build", "link")`` while the likes of python and numpy
are ``("build", "link", "run")``. Void Linux has this for its ``python3-scipy``
package::

    hostmakedepends="gcc-fortran python3-setuptools pythran python3-Cython python3-pybind11 pkg-config"
    makedepends="python3-devel python3-pybind11 pythran $(vopt_if openblas openblas-devel lapack-devel)"
    depends="python3-numpy"

So that is similar to Conda (note that host has the opposite meaning).

Examples
--------

These examples show what the ``[external-dependencies]`` content for a number
of packages is expected to be.

cryptography 39.0:

.. code:: toml

    [external-dependencies]
    build-requires = [
      "virtual:compiler{'rust'}",  # TODO: syntax? `compiler-c`, or ...?
    ]
    host-requires = [
      virtual:ssl,
    ]

SciPy 1.10:

.. code:: toml

    [external-dependencies]
    build-requires = [
      "virtual:compiler{'c'}",
      "virtual:compiler{'c++'}",
      "virtual:compiler{'fortran'}",
      "pkg:generic/ninja",
    ]
    host-requires = [
      "virtual:blas",
      "virtual:lapack",  # >=3.7.1 (can't express version ranges with PURL yet)
    ]

    [external-dependencies.optional-host-requires]
    dependency_detection = [
      "pkg:generic/pkg-config",
      "pkg:generic/cmake",
    ]

pygraphviz 1.10:

.. code:: toml

    [external-dependencies]
    build-requires = [
      "virtual:compiler{'c'}",
    ]
    host-requires = [
      "pkg:generic/graphviz",
    ]

NAVis 1.4.0:

.. code:: toml

    [project]
    optional-dependencies = ["rpy2"]

    [external-dependencies]
    build-requires = [
      "pkg:generic/XCB?os=Linux",  # ? is the PURL qualifier
      "pkg:generic/XCB; platform_system=='Linux'",  # the alternative
    ]

    [external-dependencies.optional-dependencies]
    nat = [
      "pkg:cran/nat",
      "pkg:cran/nat.nblast",
    ]

Spyder 6.0:

.. code:: toml

    [external-dependencies]
    dependencies = [
      "pkg:cargo/ripgrep",
      "pkg:cargo/tree-sitter-cli",
      "pkg:golang/github.com/junegunn/fzf",
    ]

jupyterlab-git 0.41.0:

.. code:: toml

    [external-dependencies]
    dependencies = [
      "pkg:generic/git",
    ]

    [external-dependencies.optional-build-requires]
    dev = [
      "pkg:generic/nodejs",
    ]

Backwards Compatibility
=======================

There is no impact on backwards compatibility, as this PEP only adds new,
optional metadata. In the absence of such metadata, nothing changes for package
authors or packaging tooling.


Security Implications
=====================

There are no direct security concerns as this PEP covers how to statically
define metadata for external depedencies. Any security issues would stem from
how tools consume the metadata and choose to act upon it.


How to Teach This
=================

TODO


Reference Implementation
========================


Rejected Ideas
==============

Specific syntax for external dependencies which are also packaged on PyPI
-------------------------------------------------------------------------

There are non-Python packages which are packaged on PyPI, such as Ninja,
patchelf and CMake. What is typically desired is to use the system version of
those, and if it's not present on the system then install the PyPI package for
it. The authors believe that specific support for this scenario is not
necessary (or too complex to justify such support); a dependency provider for
external dependencies can treat PyPI as one possible source for obtaining the
package.

Using library and header names as external dependencies
-------------------------------------------------------

A previous draft PEP (`"External dependencies" (2015) <https://github.com/pypa/interoperability-peps/pull/30>`__)
proposed using specific library and header names as external dependencies. This
is too granular; using package names is a well-established pattern across
packaging ecosystems and should be preferred.


Open Issues
===========

None at the moment.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


.. _PyPI: https://pypi.org
.. _core metadata: https://packaging.python.org/specifications/core-metadata/
.. _setuptools: https://setuptools.readthedocs.io/
.. _setuptools metadata: https://setuptools.readthedocs.io/en/latest/setuptools.html#metadata
.. _SPDX: https://spdx.dev/
.. _PURL: https://github.com/package-url/purl-spec/
.. _vers: https://github.com/package-url/purl-spec/blob/version-range-spec/VERSION-RANGE-SPEC.rst
.. _vers implementation for PURL: https://github.com/package-url/purl-spec/pull/139
.. _pyp2rpm: https://github.com/fedora-python/pyp2rpm
.. _Grayskull: https://github.com/conda/grayskull
.. _dh_python: https://www.debian.org/doc/packaging-manuals/python-policy/index.html#dh-python
.. _Dependabot: https://github.com/dependabot
.. _libraries.io: https://libraries.io/


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
